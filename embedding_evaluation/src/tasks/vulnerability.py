"""
Task for evaluating vulnerability pattern detection in binary code.
"""

import numpy as np
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score
from .base import BaseTask

class VulnerabilityDetectionTask(BaseTask):
    """Task for evaluating vulnerability pattern detection in binary code."""
    
    def __init__(self, similarity_threshold=0.8):
        """
        Initialize the vulnerability detection task.
        
        Args:
            similarity_threshold: Threshold for vulnerability detection
        """
        super().__init__(
            name="Vulnerability Pattern Detection",
            description="Detect code patterns similar to known vulnerabilities"
        )
        self.similarity_threshold = similarity_threshold
    
    def evaluate(self, embedding_model, test_data):
        """
        Evaluate the embedding model on vulnerability detection.
        
        Args:
            embedding_model: The embedding model to evaluate
            test_data: Dictionary with:
                - 'code_snippets': List of code snippets to check
                - 'vulnerability_patterns': List of known vulnerability patterns
                - 'labels': Boolean labels indicating if snippets are vulnerable
            
        Returns:
            dict: Evaluation results
        """
        code_snippets = test_data['code_snippets']
        vulnerability_patterns = test_data['vulnerability_patterns']
        true_labels = test_data['labels']
        
        # Calculate vulnerability scores
        vulnerability_scores = []
        
        for snippet in code_snippets:
            # Get embedding for the snippet
            snippet_emb = embedding_model.transform([snippet])[0]
            
            # Calculate similarity to each known vulnerability pattern
            pattern_similarities = []
            for pattern in vulnerability_patterns:
                pattern_emb = embedding_model.transform([pattern])[0]
                
                # Calculate cosine similarity
                snippet_norm = np.linalg.norm(snippet_emb)
                pattern_norm = np.linalg.norm(pattern_emb)
                
                if snippet_norm == 0 or pattern_norm == 0:
                    similarity = 0.0
                else:
                    similarity = np.dot(snippet_emb, pattern_emb) / (snippet_norm * pattern_norm)
                
                pattern_similarities.append(similarity)
            
            # Take maximum similarity as vulnerability score
            max_similarity = max(pattern_similarities) if pattern_similarities else 0
            vulnerability_scores.append(max_similarity)
        
        # Predict vulnerabilities based on threshold
        predictions = [score >= self.similarity_threshold for score in vulnerability_scores]
        
        # Calculate similarity matrix between snippets and patterns
        similarity_matrix = self._calculate_similarity_matrix(code_snippets, vulnerability_patterns, embedding_model)
        
        return {
            'vulnerability_scores': vulnerability_scores,
            'predictions': predictions,
            'true_labels': true_labels,
            'similarity_matrix': similarity_matrix
        }
    
    def _calculate_similarity_matrix(self, snippets, patterns, embedding_model):
        """
        Calculate similarity matrix between snippets and patterns.
        
        Args:
            snippets: List of code snippets
            patterns: List of vulnerability patterns
            embedding_model: Embedding model
            
        Returns:
            numpy.ndarray: Similarity matrix
        """
        # Get embeddings for snippets and patterns
        snippet_embeddings = embedding_model.transform(snippets)
        pattern_embeddings = embedding_model.transform(patterns)
        
        # Calculate similarity matrix
        similarity_matrix = np.zeros((len(snippets), len(patterns)))
        
        for i, snippet_emb in enumerate(snippet_embeddings):
            for j, pattern_emb in enumerate(pattern_embeddings):
                # Calculate cosine similarity
                snippet_norm = np.linalg.norm(snippet_emb)
                pattern_norm = np.linalg.norm(pattern_emb)
                
                if snippet_norm == 0 or pattern_norm == 0:
                    similarity = 0.0
                else:
                    similarity = np.dot(snippet_emb, pattern_emb) / (snippet_norm * pattern_norm)
                
                similarity_matrix[i, j] = similarity
        
        return similarity_matrix
    
    def score(self, results):
        """
        Calculate scores for vulnerability detection.
        
        Args:
            results: Results from evaluate()
            
        Returns:
            dict: Score metrics
        """
        predictions = results['predictions']
        true_labels = results['true_labels']
        vulnerability_scores = results['vulnerability_scores']
        
        # Calculate standard metrics
        accuracy = accuracy_score(true_labels, predictions)
        
        # Handle potential division by zero
        if sum(predictions) == 0:
            precision = 0
        else:
            precision = precision_score(true_labels, predictions)
            
        if sum(true_labels) == 0:
            recall = 0
        else:
            recall = recall_score(true_labels, predictions)
            
        if precision + recall == 0:
            f1 = 0
        else:
            f1 = f1_score(true_labels, predictions)
        
        # Calculate ROC AUC
        try:
            roc_auc = roc_auc_score(true_labels, vulnerability_scores)
        except ValueError:
            roc_auc = 0.5
        
        # Calculate additional metrics
        avg_score_vulnerable = np.mean([
            score for score, label in zip(vulnerability_scores, true_labels) if label
        ]) if any(true_labels) else 0
        
        avg_score_non_vulnerable = np.mean([
            score for score, label in zip(vulnerability_scores, true_labels) if not label
        ]) if not all(true_labels) else 0
        
        # Score separation (higher is better)
        score_separation = avg_score_vulnerable - avg_score_non_vulnerable
        
        # Calculate distribution of pattern matches
        pattern_match_counts = np.sum(results['similarity_matrix'] >= self.similarity_threshold, axis=0)
        
        return {
            'accuracy': accuracy,
            'precision': precision,
            'recall': recall,
            'f1': f1,
            'roc_auc': roc_auc,
            'avg_score_vulnerable': avg_score_vulnerable,
            'avg_score_non_vulnerable': avg_score_non_vulnerable,
            'score_separation': score_separation,
            'pattern_match_counts': pattern_match_counts.tolist(),
            'threshold': self.similarity_threshold
        }
    
    def generate_synthetic_data(self, num_samples=100, num_patterns=5, seed=42):
        """
        Generate synthetic data for vulnerability detection evaluation.
        
        Args:
            num_samples: Number of code snippets to generate
            num_patterns: Number of vulnerability patterns to generate
            seed: Random seed for reproducibility
            
        Returns:
            dict: Synthetic test data
        """
        np.random.seed(seed)
        
        # Define common vulnerability patterns
        vulnerability_templates = [
            # Buffer overflow vulnerable patterns
            ["mov ecx, eax", "mov rdi, rbx", "call strcpy", "test eax, eax"],
            ["mov rbx, rsi", "lea rax, [rbp-20h]", "mov rdi, rax", "call strcpy"],
            ["push rbp", "mov rbp, rsp", "sub rsp, 10h", "lea rdi, [rbp-10h]", "call gets"],
            
            # Use after free patterns
            ["call malloc", "mov rbx, rax", "mov rdi, rbx", "call free", "mov [rbx], ecx"],
            ["mov rdi, rbx", "call free", "mov rax, [rbx+8]"],
            
            # Format string vulnerabilities
            ["mov rdi, rax", "call printf"],
            ["mov rdi, [rbp-10h]", "call printf"],
            
            # Integer overflow
            ["mov eax, [rbx]", "add eax, ecx", "imul eax, 4", "mov rdi, rax", "call malloc"],
            
            # Null pointer dereference
            ["test rax, rax", "je .L1", "mov [rax], rdx", ".L1:", "mov rcx, [rax+8]"]
        ]
        
        # Generate vulnerability patterns
        patterns = []
        for i in range(min(num_patterns, len(vulnerability_templates))):
            pattern = vulnerability_templates[i]
            patterns.append(pattern)
        
        # Fill any remaining patterns with variants
        while len(patterns) < num_patterns:
            template_idx = np.random.randint(0, len(vulnerability_templates))
            template = vulnerability_templates[template_idx]
            
            # Create a variant by modifying registers
            variant = []
            for instr in template:
                # Replace registers with alternatives
                new_instr = instr
                for reg_old, reg_new in [('rax', 'rbx'), ('rbx', 'rcx'), ('rcx', 'rdx'), ('rdx', 'rsi'), 
                                         ('rsi', 'rdi'), ('rdi', 'r8'), ('r8', 'r9'), ('eax', 'ebx')]:
                    if np.random.random() < 0.5:
                        new_instr = new_instr.replace(reg_old, reg_new)
                
                variant.append(new_instr)
            
            patterns.append(variant)
        
        # Generate code snippets and labels
        code_snippets = []
        labels = []
        
        for _ in range(num_samples):
            if np.random.random() < 0.5:  # 50% vulnerable, 50% non-vulnerable
                # Create a vulnerable snippet
                pattern_idx = np.random.randint(0, len(patterns))
                pattern = patterns[pattern_idx]
                
                # Create a variant of the pattern
                snippet = []
                for instr in pattern:
                    # Add some random noise but keep the key vulnerability
                    if np.random.random() < 0.2:
                        # Add a benign instruction
                        snippet.append("mov r10, r11")
                    
                    # Keep the vulnerable instruction
                    snippet.append(instr)
                
                # Add some padding
                padding_length = np.random.randint(1, 5)
                for _ in range(padding_length):
                    snippet.append("xor eax, eax")
                
                code_snippets.append(snippet)
                labels.append(True)
            else:
                # Create a non-vulnerable snippet
                snippet_length = np.random.randint(3, 10)
                snippet = []
                
                for _ in range(snippet_length):
                    # Add benign instructions
                    instr_type = np.random.randint(0, 5)
                    
                    if instr_type == 0:
                        snippet.append("mov eax, ebx")
                    elif instr_type == 1:
                        snippet.append("add eax, ecx")
                    elif instr_type == 2:
                        snippet.append("push rbp")
                    elif instr_type == 3:
                        snippet.append("pop rbp")
                    else:
                        snippet.append("xor eax, eax")
                
                code_snippets.append(snippet)
                labels.append(False)
        
        return {
            'code_snippets': code_snippets,
            'vulnerability_patterns': patterns,
            'labels': labels
        }